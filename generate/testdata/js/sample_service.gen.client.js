// Code generated by Frodo - DO NOT EDIT.
//
//   Timestamp: Wed, 05 Nov 2025 06:37:59 EST
//   Source:    sample_service.go
//   Generator: https://github.com/bridgekit-io/frodo
//
/* global fetch,module,window,WebSocket,Request,Response */
'use strict';






/**
 * Exposes all of the standard operations for the remote SampleService service. These RPC calls
 * will be sent over http(s) to the backend service instances. 
 * SampleService is a mix of different options, parameter setups, and responses so that we can
 * run integration tests using our code-generated clients. Each method is nothing special, but
 * they each do something a little differently than the rest to flex different parts of the framework.
 */
class SampleServiceClient {
  _fetch;
  /** @type {string} */
  _baseURL;
  /** @type {string|function():string} */
  _authorization;
  /** @type { testext~SampleServiceMiddleware } */
  _middleware;

  /**
   * @param {string} baseURL The protocol/host/port used by all API/service
   *     calls (e.g. "https://some-server:9000")
   * @param {object} [options]
   * @param {fetch|*} [options.fetch] Provide a custom implementation for the 'fetch' API. Not
   *     necessary if running in browser.
   * @param {string|function():string} [options.authorization] Use these credentials in the HTTP Authorization
   *      header for every request. Only use the client-level authorization when all requests to the
   *      service should have the same credentials. If you allow multiple users in your system,
   *      leave this blank and use the authorization option on each request.
   * @param { testext~SampleServiceMiddleware } [options.middleware] A handler function that lets you perform tasks
   *      before and after the actual HTTP request dispatching which allows you to inject behaviors/logs
   *      or intercept responses before they're processed by the client. Great for adding retry logic.
   */
  constructor(baseURL, {fetch, authorization, middleware} = {}) {
    this._baseURL = trimSlashes(baseURL);
    this._baseSocketURL = this._baseURL.startsWith("http://")
      ? this._baseURL.replace("http://", "ws://")
      : this._baseURL.replace("https://", "wss://");

    this._fetch = fetch || defaultFetch();
    this._authorization = authorization || "";
    this._middleware = middleware || ((url, options, next) => next(url, options));
  }
  
  /**
   * Authorization regurgitates the "Authorization" metadata/header. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Authorization(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Authorization";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Chain1 kicks off the Chain1/Chain2/Chain3 event chain, but we expect that it's going to stop after 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Chain1(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Chain1";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Chain1GroupFooBar listens for calls to Chain1, but rather than being part of a consumer group that only lets 
   * one instance of the service run it, it should define its own shared group name. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Chain1GroupFooBar(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Chain1GroupFooBar";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Chain1GroupStar listens for calls to Chain1, but rather than being part of a consumer group that only lets 
   * one instance of the service run it, it should define its own group that lets EVERY instance of this service 
   * react to this event. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Chain1GroupStar(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Chain1GroupStar";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Chain2 ALWAYS FAILS, SO CHAIN3 NEVER FIRES!!! 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Chain2(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Chain2";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Chain2OnError listens for errors that occur on calls to Chain2 
   *
   * @param { testext~FailAlwaysErrorRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~FailAlwaysErrorResponse> } The JSON-encoded return value of the operation.
   */
  async Chain2OnError(serviceRequest, {authorization} = {}) {
    throw new GatewayError(501, "Chain2OnError is not supported in the API gateway");
  
  }
  
  
  /**
   * Chain2OnSuccess never fires. It listens for the success of Chain2, but since that always fails, this 
   * should never be triggered, so tests should never have this in its output. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Chain2OnSuccess(serviceRequest, {authorization} = {}) {
    throw new GatewayError(501, "Chain2OnSuccess is not supported in the API gateway");
  
  }
  
  
  /**
   * ComplexValues flexes our ability to encode/decode non-flat structs. 
   *
   * @param { testext~SampleComplexRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleComplexResponse> } The JSON-encoded return value of the operation.
   */
  async ComplexValues(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.ComplexValues";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * ComplexValuesPath flexes our ability to encode/decode non-flat structs while 
   * specifying them via path and query string. 
   *
   * @param { testext~SampleComplexRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleComplexResponse> } The JSON-encoded return value of the operation.
   */
  async ComplexValuesPath(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/complex/values/{InUser.ID}/{InUser.Name}/woot";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * CustomRoute performs a service operation where you override default behavior 
   * by providing routing-related Doc Options. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async CustomRoute(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/custom/route/1/{ID}/{Text}";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * CustomRouteBody performs a service operation where you override default behavior 
   * by providing routing-related Doc Options, but rely on body encoding rather than path. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async CustomRouteBody(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "PUT";
    const route = "/v2/custom/route/3/{ID}";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * CustomRouteQuery performs a service operation where you override default behavior 
   * by providing routing-related Doc Options. The input data relies on the path 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async CustomRouteQuery(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/custom/route/2/{ID}";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Defaults simply utilizes all of the framework's default behaviors. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Defaults(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Defaults";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Download results in a raw stream of data rather than relying on auto-encoding 
   * the response value. 
   *
   * @param { testext~SampleDownloadRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleDownloadResponse> | StreamedResponse } The raw stream data returned by the server.
   */
  async Download(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/download";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponseStream(response);

  
  }
  
  
  /**
   * DownloadResumable results in a raw stream of data rather than relying on auto-encoding 
   * the response value. The stream includes Content-Range info as though you could resume 
   * your stream/download progress later. 
   *
   * @param { testext~SampleDownloadRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleDownloadResponse> | StreamedResponse } The raw stream data returned by the server.
   */
  async DownloadResumable(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/download/resumable";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponseStream(response);

  
  }
  
  
  /**
   * Fail4XX always returns a non-nil 400-series error. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Fail4XX(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Fail4XX";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Fail5XX always returns a non-nil 500-series error. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Fail5XX(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Fail5XX";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * FailAlways will return an error no matter what. It's only goal in life is to trigger OnFailAlways. 
   *
   * @param { testext~FailAlwaysRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~FailAlwaysResponse> } The JSON-encoded return value of the operation.
   */
  async FailAlways(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.FailAlways";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * ListenerA fires on only one of the triggers. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async ListenerA(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/ListenerA/Woot";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * ListenerB fires on multiple triggers... including another event-based endpoint. We also 
   * listen for the TriggerFailure event which should never fire properly. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async ListenerB(serviceRequest, {authorization} = {}) {
    throw new GatewayError(501, "ListenerB is not supported in the API gateway");
  
  }
  
  
  /**
   * OmitMe exists in the service, but should be excluded from the public API. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async OmitMe(serviceRequest, {authorization} = {}) {
    throw new GatewayError(501, "OmitMe is not supported in the API gateway");
  
  }
  
  
  /**
   * OnFailAlways should trigger after FailAlways inevitably shits the bed. 
   *
   * @param { testext~FailAlwaysErrorRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~FailAlwaysErrorResponse> } The JSON-encoded return value of the operation.
   */
  async OnFailAlways(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.OnFailAlways";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Panic um... panics. It never succeeds. It always behaves like me when I'm on a high place looking down. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Panic(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Panic";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Redirect results in a 307-style redirect to the Download endpoint. 
   *
   * @param { testext~SampleRedirectRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleRedirectResponse> | StreamedResponse } The raw stream data returned by the server.
   */
  async Redirect(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/redirect";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponseStream(response);

  
  }
  
  
  /**
   * SecureWithRoles lets us test role based security by looking at the 'roles' doc option. 
   *
   * @param { testext~SampleSecurityRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleSecurityResponse> } The JSON-encoded return value of the operation.
   */
  async SecureWithRoles(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.SecureWithRoles";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * SecureWithRolesAliased lets us test role based security by looking at the 'roles' doc option. Specifically, 
   * we make sure we can resolve role segments with string alias types, not just strings. 
   *
   * @param { testext~SampleSecurityRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleSecurityResponse> } The JSON-encoded return value of the operation.
   */
  async SecureWithRolesAliased(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.SecureWithRolesAliased";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * Sleep successfully responds, but it will sleep for 5 seconds before doing so. Use this 
   * for test cases where you want to try out timeouts. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async Sleep(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.Sleep";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   *  
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async TriggerFailure(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.TriggerFailure";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   *  
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async TriggerLowerCase(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "POST";
    const route = "/v2/SampleService.TriggerLowerCase";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(serviceRequest),
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
  
  /**
   * TriggerUpperCase ensures that events still fire as "SampleService.TriggerUpperCase" even though 
   * we are going to set a different HTTP path. 
   *
   * @param { testext~SampleRequest } serviceRequest The input parameters
   * @param {object} [options]
   * @param { string } [options.authorization] The HTTP Authorization header value to include
   *     in the request. This will override any authorization you might have applied when
   *     constructing this client. Use this in multi-tenant situations where multiple users
   *     might utilize this service.
   * @returns {Promise<testext~SampleResponse> } The JSON-encoded return value of the operation.
   */
  async TriggerUpperCase(serviceRequest, {authorization} = {}) {
    if (!serviceRequest) {
      throw new GatewayError(400, "precondition failed: empty request");
    }

    const method = "GET";
    const route = "/v2/Upper/Case/WootyAndTheBlowfish";
    const requestPath = buildRequestPath(method, route, serviceRequest);
    const authToken = (resolveString(authorization) || resolveString(this._authorization) || "").trim();
    const fetchURL = this._baseURL + "/" + requestPath;
    const fetchOptions = {
      method: method,
      headers: {
        "Authorization": authToken ? "Bearer " + authToken : "",
        "Accept": "application/json,*/*",
        "Content-Type": "application/json; charset=utf-8",
      },
    };

    // const response = await doFetch(this._fetch, fetchURL, fetchOptions);
    const response = await this._middleware(fetchURL, fetchOptions, doFetch.bind(null, this._fetch));
    return handleResponse(response);

  
  }
  
}

/**
 * Fills in a router path pattern such as "/user/{id}", with the appropriate attribute from
 * the 'serviceRequest' instance.
 *
 * @param {string} method The HTTP method for this request (determines if we include a query string)
 * @param {string} path The path pattern to populate w/ runtime values (e.g. "/user/{id}")
 * @param {Object} serviceRequest The input struct for the service call
 * @returns {string} The fully-populate URL path (e.g. "/user/aCx31s")
 */
function buildRequestPath(method, path, serviceRequest) {
  const values = new URLValues(serviceRequest);

  const pathSegments = path.split("/").map(segment => {
    return segment.startsWith("{") && segment.endsWith("}")
      ? encodeURIComponent(values.get(segment.substring(1, segment.length - 1)))
      : segment;
  });
  const resolvedPath = trimSlashes(pathSegments.join("/"));

  // PUT/POST/PATCH:  encode the data in the body, so no need to shove it in the query string.
  // GET/DELETE/HEAD: will pass all values through the query string.
  return supportsBody(method)
    ? resolvedPath
    : resolvedPath + "?" + values.format();
}

/**
 * URLValues helps convert a single request object into a map of individual attributes that can
 * be easily added to a path or query string.
 *
 * Example:
 * ```
 * let req = {
 *   ID: "123",
 *   Name: "Bob",
 *   Alive: true,
 *   ContactInfo: {
 *     PhoneNumber: "123-555-1234",
 *     Emails: { Home: "me@you.com", Work: "work@you.com" },
 *   },
 * };
 *
 * let values = URLValues(req);
 * console.info(values.get("ID"));                     // 123
 * console.info(values.get("Alive"));                  // true
 * console.info(values.get("ContactInfo.Email.Home")); // me@you.com
 * ```
 */
class URLValues {
  constructor(struct) {
    this.struct = struct;
    this.attrs = {};
    this._load(struct, "");
  }

  get(name) {
    return this.attrs[name] || "";
  }

  format() {
    const attrs = this.attrs;
    return Object.getOwnPropertyNames(this.attrs)
      .map(attr => this.formatAttribute(attr, attrs[attr]))
      .join("&");
  }

  formatAttribute(name, value) {
    return Array.isArray(value)
      ? value.map(v => this.formatAttribute(name, v)).join("&")
      : name + "=" + encodeURIComponent(value);
  }

  _load(value, prefix = "") {
    for (let propertyName of Object.getOwnPropertyNames(value)) {
      let propertyValue = value[propertyName];
      let propertyKey = prefix ? prefix + "." + propertyName : propertyName;

      if (propertyValue === null) {
        continue;
      }

      if (Array.isArray(propertyValue)) {
        this.attrs[propertyKey] = propertyValue;
        continue;
      }

      switch (typeof propertyValue) {
        case "undefined":
        case "symbol":
          continue;

        case "function":
          this.attrs[propertyKey] = propertyValue();
          continue;

        case "boolean":
        case "number":
        case "bigint":
        case "string":
          this.attrs[propertyKey] = propertyValue;
          continue;

        default:
          this._load(propertyValue, propertyKey);
      }
    }
  }
}

/**
 * Accepts the full response data and the request's promise resolve/reject and determines
 * which to invoke. This will also JSON-unmarshal the response data if need be.
 */
async function handleResponse(response) {
  if (response.status >= 400) {
    throw await newError(response);
  }

  switch (response.headers.get("content-type")) {
  case "application/json":
  case "text/json":
    return response.json();
  default:
    return response.blob();
  }
}

/**
 * Accepts the full response data and the request's promise resolve/reject and determines
 * which to invoke. This assumes that you want the raw bytes as a blob from the HTTP response
 * rather than treating it like JSON. This will also capture the Content-Type value as well as
 * the "filename" from the Content-Disposition if it's set to "attachment".
 *
 * @returns { StreamedResponse }
 */
async function handleResponseStream(response) {
  if (response.status >= 400) {
    throw await newError(response);
  }
  const content = await response.blob();
  const contentType = response.headers.get("content-type") || "application/octet-stream";
  const contentFileName = dispositionFileName(response.headers.get("content-disposition"));
  const contentLength = toInt(response.headers.get("content-length")) || 0;
  const contentRange = parseContentRange(response.headers.get("content-range"));

  return {
      Content: content,
      ContentType: contentType,
      ContentLength: contentLength,
      ContentFileName: contentFileName,
      ContentRange: contentRange,
  };
}

/**
 * Given an option that's allowed to either be a string or a function that returns a string, do what
 * thou must in order to get the desired string value.
 */
function resolveString(value) {
  if (!value) {
    return "";
  }
  if (typeof value === "function") {
    return value();
  }
  return value + "";
}

/**
 * Accepts the 'Content-Range' header value from a response and parses out all 4 components
 * of the value; the unit, start, end, and size. You'll get back a single object containing
 * all 4 values.
 *
 * @returns {ContentRange}
 */
function parseContentRange(range) {
  range = range && range.trim()
  if (!range) {
      return {Unit: "bytes", Start: 0, End: 0, Size: 0};
  }

  let matches = range.match(/^(\w*) /);
  const unit = matches && matches[1];

  matches = range.match(/(\d+)-(\d+)\/(\d+|\*)/);
  if (matches) {
    return {
      Unit: unit || "bytes",
      Start: toInt(matches[1]),
      End: toInt(matches[2]),
      Size: matches[3] === "*" ? null : toInt(matches[3])
    };
  }
}

/**
 * An alternative to the standard 'parseInt' that handles shittier cases like "5x1". Standard
 * parseInt() returns 5 whereas toInt() returns NaN as you'd expect.
 */
function toInt(value) {
  const num = Number(value);
  return num >= 0 ? Math.floor(num) : Math.ceil(num);
}

/**
 * Creates a new GatewayError with all of the meaningful status/message info extracted
 * from the HTTP response.
 *
 * @returns {Promise< GatewayError >}
 */
async function newError(response) {
  const body = isJSON(response)
    ? await response.json()
    : await response.text();

  // One of the framework's standard status/message errors, already.
  throw (body["Status"] && body["Message"])
    ? new GatewayError(body["Status"], body["Message"])
    : new GatewayError(response.status, parseErrorMessage(body));
}

/**
 * Parses a value from the Content-Disposition header to extract just the filename attribute.
 *
 * @param {string} contentDisposition
 * @returns {string}
 */
function dispositionFileName(contentDisposition = "") {
  contentDisposition = contentDisposition && contentDisposition.trim();
  if (!contentDisposition) {
    return "";
  }

  const fileNameAttrPos = contentDisposition.indexOf("filename=");
  if (fileNameAttrPos < 0) {
    return "";
  }

  let fileName = contentDisposition.substring(fileNameAttrPos + 9);
  fileName = fileName.startsWith('"') ? fileName.substring(1) : fileName;
  fileName = fileName.endsWith('"') ? fileName.substring(0, fileName.length - 1) : fileName;
  fileName = fileName.replace(/\\"/g, '"');
  return fileName;
}

/**
 * Determines whether the response has a content type of JSON.
 */
function isJSON(response) {
  const contentType = response.headers.get("content-type");
  return contentType && contentType.toLowerCase().startsWith("application/json");
}

/**
* Looks at the response value and attempts to peel off an error message from it using the standard
* error JSON structures used by frodo gateways.
*
* @param {*} err The error whose raw message you're trying to extract.
* @returns {string}
*/
function parseErrorMessage(err) {
  if (typeof err === "string") {
    return err;
  }
  if (typeof err.message !== "undefined") {
    return err.message;
  }
  if (typeof err.error !== "undefined") {
    return err.error;
  }
  return JSON.stringify(err);
}

/**
 * Does the HTTP method given support supplying data in the body of the request? For instance
 * this is true for POST but not for GET.
 *
 * @param {string} method The HTTP method that you are processing (e.g. "GET", "POST", etc.)
 * @returns {boolean}
 */
function supportsBody(method) {
  return method === "POST" || method === "PUT" || method === "PATCH";
}

/**
 * Removes all leading/trailing slashes from the given URL segment.
 *
 * @param {string} value The URL path segment to clean up.
 * @returns {string}
 */
function trimSlashes(value) {
  if (!value) {
    return "";
  }
  while (value.startsWith("/")) {
    value = value.substring(1);
  }
  while (value.endsWith("/")) {
    value = value.substring(0, value.length - 1);
  }
  return value;
}

/**
* When you don't supply your own Fetch implementation, this will attempt to use
* any globally defined ones (typically for use in the browser).
*
* @returns {fetch}
*/
function defaultFetch() {
  const runningInBrowser = typeof window !== "undefined";

  if (typeof fetch === "undefined") {
    throw runningInBrowser
      ? new GatewayError(400, "no global 'fetch' found - unsupported browser")
      : new GatewayError(400, "no global 'fetch' found - upgrade to Node 18+ or install/import node-fetch");
  }
  return runningInBrowser ? fetch.bind(window) : fetch;
}

/**
 * Dispatches your 'fetch' request to the server. Any low-level connection failures will be
 * wrapped in a GatewayError, so we have consistent status codes to better handle error categories.
 */
async function doFetch(fetchFunc, url, options) {
  try {
    return await fetchFunc(url, options);
  } catch (e) {
    throw new GatewayError(502, e.toString());
  }
}

/**
* GatewayError is a rich error type that encapsulates a failure generated by the remote gateway.
* It captures the server's error message as well as HTTP status so you can properly handle the
* result in your consumer code.
*/
class GatewayError {
  /**
   * The HTTP 4XX/5XX status code of the failure.
   * @type {number}
   */
  status;

  /**
   * The user-facing message that the server generated for the error.
   * @type {string}
   */
  message;

  constructor(status, message) {
    this.Status = this.status = status || 500;
    this.Message = this.message = message;
  }

  toString() {
    return this.status + ": " + this.message;
  }
}



/**
 * @typedef { number } testext~CustomDuration
 * 
*/
/**
 * @typedef { number } time~Duration
 * 
*/
/**
 * @typedef { object } testext~SampleRequest
 * 
 * @property { string|* } [ID]
 * @property { string|* } [Text]
*/
/**
 * @typedef { object } testext~FailAlwaysErrorRequest
 * 
 * @property { testext~EventError|* } [Error]
 * @property { string|* } [RequestValue]
 * @property { string|* } [ResponseValue]
 * @property { string|* } [Text]
*/
/**
 * @typedef { object } testext~FailAlwaysResponse
 * 
 * @property { string|* } [ResponseValue]
*/
/**
 * @typedef { object } testext~SampleSecurityRequest
 * 
 * @property { string|* } [ID]
 * @property { testext~SampleUser|* } [User]
 * @property { testext~StringLike|* } [FancyID]
*/
/**
 * @typedef { object } testext~SampleUser
 * 
 * @property { string|* } [ID]
 * @property { testext~StringLike|* } [FancyID]
 * @property { string|* } [Name]
 * @property { number|* } [Age]
 * @property { time~Duration|* } [Attention]
 * @property { testext~CustomDuration|* } [AttentionString]
 * @property { string|* } [Digits]
 * @property { testext~MarshalToString|* } [MarshalToString]
 * @property { testext~MarshalToObject|* } [MarshalToObject]
*/
/**
 * @typedef { object } time~Time
 * 
*/
/**
 * @typedef { object } testext~SampleSecurityResponse
 * 
 * @property { Array<string>|* } [Roles]
*/
/**
 * @typedef { object } testext~MarshalToObject
 * 
 * @property { string|* } [Home]
 * @property { string|* } [Work]
*/
/**
 * @typedef { object } testext~MarshalToString
 * 
 * @property { string|* } [Home]
 * @property { string|* } [Work]
*/
/**
 * @typedef { object } testext~SampleComplexRequest
 * 
 * @property { testext~SampleUser|* } [InUser]
 * @property { boolean|* } [InFlag]
 * @property { number|* } [InFloat]
 * @property { time~Time|* } [InTime]
 * @property { time~Time|* } [InTimePtr]
 * @property { Array<string>|* } [InStringSlice]
*/
/**
 * @typedef { string } testext~StringLike
 * 
*/
/**
 * @typedef { object } testext~SampleDownloadRequest
 * 
 * @property { string|* } [Format]
*/
/**
 * @typedef { object } testext~FailAlwaysRequest
 * 
 * @property { string|* } [RequestValue]
*/
/**
 * @typedef { object } testext~SampleRedirectResponse
 * 
 * @property { string|* } [URI]
*/
/**
 * @typedef { object } testext~SampleResponse
 * 
 * @property { string|* } [ID]
 * @property { string|* } [Text]
*/
/**
 * @typedef { object } testext~EventError
 * 
 * @property { string|* } [Message]
 * @property { string|* } [Error]
 * @property { number|* } [Code]
 * @property { number|* } [Status]
 * @property { number|* } [StatusCode]
 * @property { number|* } [HTTPStatusCode]
*/
/**
 * @typedef { object } testext~FailAlwaysErrorResponse
 * 
*/
/**
 * @typedef { object } testext~SampleComplexResponse
 * 
 * @property { boolean|* } [OutFlag]
 * @property { number|* } [OutFloat]
 * @property { testext~SampleUser|* } [OutUser]
 * @property { time~Time|* } [OutTime]
 * @property { time~Time|* } [OutTimePtr]
 * @property { Array<string>|* } [OutStringSlice]
*/
/**
 * @typedef { object } testext~SampleDownloadResponse
 * 
*/
/**
 * @typedef { object } testext~SampleRedirectRequest
 * 
*/

/**
 * @typedef StreamedResponse
 * @property { Blob } Content
 * @property { string } ContentType
 * @property { number } ContentLength
 * @property { ContentRange } ContentRange
*/

/**
 * @typedef ContentRange
 * @property { string } [Unit]
 * @property { number } [Start]
 * @property { number } [End]
 * @property { number } [Size]
 */

/** @namespace testext */

/** @namespace time */


/**
 * @callback testext~SampleServiceMiddleware
 * @param {string} url The fully-qualified address for the request.
 * @param {RequestInit} options The Fetch/Request options like the method, headers, etc.
 * @param {function(string,RequestInit):Response} next The continuation to actually perform the HTTP fetch.
 * @returns {Promise<Response>}
 */

export { SampleServiceClient };
